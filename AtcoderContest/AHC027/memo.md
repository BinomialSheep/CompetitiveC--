


## 効率的な全経路探索について
自明解としてDFSを書く。
DFSは葉以外を毎回2回通るので無駄が多い。「最後の分岐より後でより根に近い頂点に隣接しているならそこに戻る」とか、非再帰DFSにして柔軟にスタック操作する改修を入れ、スコアは改善したがこの改修時間は無駄だった。

盤面サイズは40*40で、初期解のターン数は高々数千なので「毎回未訪問頂点までBFSして、経路復元する」でよい。

## どの順番に探索するか



## 汚れ

## 山登りの近傍





## 1日目

自明解をDFSで作るけどまぁまぁ大変。

ルールベースの上手い解がまったく思いつかない。コストが高いところにちょこちょこ立ち寄りたいが。
近傍は何パターンか思いつくのでやってみる。
DFSの順番をプレイアウトするのもありそう。
迷路的に繋がっているところを部分破壊して再構築という手もあるか。
スコア差分計算の高速化もある。
とりあえずいくつか入れてからビジュアライザを見るぞ。

- [x] スコア計算を作る
- [x] 入れ替える近傍：同一頂点までの経路をswapをする
- 増やす近傍：ある頂点から隣接頂点に移動（深さ1のDFS）
- 減らす近傍：同一頂点間の経路が他で訪問済みならまとめて削除可能

### 01.cpp
自明解

### 02.cpp
スコア計算を作った。
入れ替える近傍を書いたけど、意味ないなこれ。




## 2日目
PASTエキスパートを取った後ABCで大爆死したのでふて寝

## 3日目
近傍を書いていく。


- [x] 増やす近傍：ある頂点から隣接頂点に移動（深さ1のDFS）
- [x] DFSで戻るところをサボる
- [x] 手元でマルチテストできるようにしてスコアをスプレッドシートで管理
- [x] 増やす近傍を深さ2以上にする
- [x] 減らす近傍：同一頂点間の経路が他で訪問済みならまとめて削除可能
- [x] DFSの探索順は、1手先のスコアが大きいところにする（理由：根になれば何度も通るので）
以下思いつき
- [x] 帰りをショートカットする時に、できるだけ前までショートカットする
- 更新の高速化（ノーアイディア）
- 部分破壊して再構築
- 同じところに何度も来てるなら、探索順を丸ごと繋ぎ変えてもよい
- リバースでスコアが変わらない理由をちゃんと考えてみる
- 初期解の貪欲プレイアウト
### 03.cpp
増やす近傍を書いた。
1800～4000回くらいしかループが回っていない。
N = 33で
1.8秒
cnt: 2559 | addCnt: 7
calcScore(cells, (int)ans.size()): 7343397
18秒
cnt: 25269 | addCnt: 19
まぁそれ以上に深さ1の増やす近傍（山登り）は明らかに効果が薄い。
「直前で掃除した場所に戻る」という動きの効率がかなり悪い。

250位くらい。

### 04.cpp
DFSの帰り道のショートカットを書いた。
これはまぁスコア上がるよねという感じ。
cnt: 666 | addCnt: 1
(int)ans.size(): 2018
calcScore(cells, (int)ans.size()): 6891070

234位。意外と悪い。
アニメーションを見ていて気付いたけど、「先に掃除しておけば上手く回れたのに……」という箇所があるので探索順の工夫が必要。
2,553,639,644


### 05.cpp
「1手先のスコアが大きい」ところを優先して探索するようにした。
2,290,373,480
手元では改善してるけど、提出は微減。
秩序のない探索をするので、あまりよくはないみたい？

### マルチテストケース
#!/bin/sh

for i in $(seq -w 0 99)
do
	./a.out < in/00${i}.txt > out/00${i}.txt 2>> debug.txt
	# echo ${i}
done

### 06.cpp
増やす近傍をDFSできるようにした。
DFSを初期解と同じ順でやるのは意味がないが、初期解の時点でランダマイズするのは05.cppの理由でダメ。
初期解は秩序的に探索し、近傍ではランダムに探索するようにした。
が、深さ3以上のDFSではほぼスコア改善しないし、深さ1の近傍は03.cppなので、大変さの割に実りがない。
スコアは僅かに改善。
2,197,219,497

### 07.cpp
削除近傍を生やした。
スコア改善以前にdeleatable（2頂点の間は全て他の探索で通る）が意外と少ない。500ループに1回くらいしかdeleatableにならない。
まぁ追加近傍をいろいろ書くうちに削除近傍が必要になると思うのでよい。
2,201,168,642

「ショートカットでできるだけ戻る」は有望だけど、他はどうか。
盤面の高速化や、プレイアウト系の探索を考える必要があるか。

### 08.cpp
帰り道のショートカットの改善。
できるだけ大きくショートカットできるようにしたのと、バグがあったので修正した。
cnt: 1221 | addCnt: 0 | delCnt: 0 | dfsCnt: 0
5670589
18秒
cnt: 12397 | addCnt: 0 | delCnt: 0 | dfsCnt: 0
5670589
山登りできなくて悲しい。

1,756,894,853
スコアは相当改善されている。
161で青パフォ圏内に入った。

## 4日目
- [x] 初期解の貪欲プレイアウト

### 09.cpp
バグらせまくった。遅い。性能が思ったより伸びない。悲しい……。
1,653,986,600
1152334041
手元ではまぁまぁ伸びてるけど、提出は微妙。224位。



### 5日目


### 10.cpp
DFSをやめた。
1,780,021,722
1230890443	
スコアは下がってるけど、2secになった上に自由度が増したのでよい。

### 11.cpp
分岐点に戻るまでを改良していく。未訪問点や汚れが多いところを優先。
1,748,562,751
想定通り多少改善。
バグがあるらしい。
「スタックに突っ込む」「親がいなければいれる」「pathに突っ込む」「visitedに入れる」あたりを整理する必要がある。


- [x]DFSをやめる
- 分岐点に戻るまでに分岐ができたら追加する
- 分岐点から狭い方を優先して探索する
- 雑に、汚れているところへ行って掃除するのを入れる
- 2optっぽくやる
- 更新の高速化（ノーアイディア）


### 6日目
### 12.cpp
11のバグを直した。
「分岐があればそこから再開（取り出したtopはスタックに入れ直す）」「スタックの頂点を取り出し、path.back()からDFS」に整理したことで、parent配列がいらなくなった。
ついでに分岐点の隣に直接BFSできるようになった
1,736,842,154
1208176504

### 13.cpp
汚れエリアを雑に計算して、適宜そこを掃除するようにした。
1,589,222,382
1141961906
168ms

- 実はstackのトップじゃなくて分岐点のどこに戻ってもいいので、setに突っ込んでBFSとかの方がいい？
 - というかBFSして最初の未訪問点に行けばいいかも

 ## 7日目
 ### 14.cpp
 BFSベースにした。
1181824025	

### 15.cpp
最短経路復元をDPにした。
1164664450
1,682,759,405
327位らしい。マジですか？？

## 8日目
汚いところを列挙し、BFSベースで掃除する。
1028450928
1,431,462,234
266位。厳しい……。


- BFSベースの初期解にたどり着くまでに時間が掛かった
- DPが非厳密
- 寄り道、2-opt系の近傍が上手くいかず、焼きなまし効果が弱い
- 汚いところを列挙する部分を「パラメータとして詰めきる」「上手く全探索する」「動的に最適化する」などをすると多少は上がりそう